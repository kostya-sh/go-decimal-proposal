package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"strconv"
)

// This program generates test data to drive tests for arbitrary precision
// decimal implementation in Go.
//
// File format spec: http://speleotrove.com/decimal/dectest.pdf
//
// Testcase files:
//   http://speleotrove.com/decimal/dectest.zip
//   http://speleotrove.com/decimal/dectest0.zip

// testcase environment
// see http://speleotrove.com/decimal/dtfile.html#direct
type testEnv struct {
	// required directives with no default values
	precision   uint
	rounding    string
	maxExponent uint
	minExponent int

	// optional directives
	version  string
	extended int // 0 or 1 (the default)
	clamp    int // 0 (the default) or 1
}

// generate reads a file in dectest format from in and generates a Go source
// file with the test data for a single operation (like add or neg)
func generate(in io.Reader, out io.Writer) error {
	w := bufio.NewWriter(out)

	fmt.Fprintln(w, "package big2")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "// Generated by dectest. DO NOT EDIT")
	fmt.Fprintln(w, "")

	s := bufio.NewScanner(in)
	var err error
	var stmt statement
	env := testEnv{}
	var op *operation
	initialComments := new(bytes.Buffer)
	seenDirective := false
	for stmt, err = nextStatement(s); stmt != nil && err == nil; stmt, err = nextStatement(s) {
		switch t := stmt.(type) {
		case *test:
			if op == nil {
				// first test
				op = findOperation(t.operation)
				if op == nil {
					return fmt.Errorf("Unsupported operation: %s", t.operation)
				}

				if op.importMathBig {
					fmt.Fprintln(w, "import \"math/big\"")
					fmt.Fprintln(w, "")
				}

				fmt.Fprintf(w, "var %sTests = []struct {\n", op.name)
				for _, f := range op.structFields {
					fmt.Fprintf(w, "\t%s\n", f)
				}
				fmt.Fprintln(w, "}{")
				_, err := initialComments.WriteTo(w)
				if err != nil {
					return err
				}
			}

			testLine := op.testDataFunc(t, &env)
			if testLine != "" {
				fmt.Fprintf(w, "\t// %s\n", t.src)
				fmt.Fprintf(w, "\t{%s},\n", testLine)
			} else {
				fmt.Fprintf(w, "\t// SKIP: %s\n", t.src)
			}

		case *directive:
			seenDirective = true
			switch t.keyword {
			case "precision":
				p, err := strconv.Atoi(t.value)
				if err != nil {
					return err
				}
				env.precision = uint(p)
			case "rounding":
				env.rounding = t.value
			}
			if op == nil {
				fmt.Fprintf(initialComments, "\t// %s\n", t)
			} else {
				fmt.Fprintf(w, "\t// %s\n", t)
			}
		case comment:
			if seenDirective {
				// start collecting comments only after a frist directive
				// (usually version) to avoid including a big header that comes
				// at the beggining of every dectest file.
				if op == nil {
					fmt.Fprintf(initialComments, "\t//%s\n", t)
				} else {
					fmt.Fprintf(w, "\t//%s\n", t)
				}
			}

		default:
			fmt.Fprintf(w, "\t// ERROR: %#v", stmt)
		}
	}
	if err != nil {
		return err
	}
	fmt.Fprintln(w, "}")

	return w.Flush()
}

func main() {
	err := generate(os.Stdin, os.Stdout)
	if err != nil {
		fmt.Printf("ERROR: %s\n", err)
	}
}
